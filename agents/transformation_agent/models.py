"""
Pydantic models for the Lakehouse Transformation Agent.

Defines the TransformationPlan output structure that maps ingested tables
to automated transformation pipelines (gold layer jobs).
"""

from __future__ import annotations

import re

from pydantic import BaseModel, Field, field_validator


class TransformJob(BaseModel):
    """A single transformation job to create in the gold layer."""

    domain: str = Field(
        ...,
        description="Business domain (e.g., starwars, sales, finance)",
    )
    job_name: str = Field(
        ...,
        description="snake_case job name (e.g., daily_revenue, people_per_planet)",
    )
    query: str = Field(
        ...,
        description=(
            "SQL query using domain.silver.table or domain.gold.job_name references "
            "(e.g., SELECT date, SUM(amount) as revenue FROM sales.silver.orders GROUP BY date)"
        ),
    )
    write_mode: str = Field(
        default="append",
        description=(
            "Write mode: 'append' (incremental upsert — preferred for performance) "
            "or 'overwrite' (full refresh — use sparingly)"
        ),
    )
    unique_key: str | None = Field(
        default=None,
        description=(
            "Column used for deduplication in append mode (upsert key). "
            "MUST be set when write_mode is 'append'. Typically the GROUP BY "
            "column(s) or entity PK."
        ),
    )
    schedule_type: str = Field(
        default="cron",
        description="Schedule type: 'cron' (time-based) or 'dependency' (triggered by upstream)",
    )
    cron_schedule: str = Field(
        default="day",
        description="Cron schedule shorthand: 'hour', 'day', or 'month'",
    )
    description: str = Field(
        default="",
        description="Human-readable description of what this transformation does and why",
    )
    dependencies: list[str] = Field(
        default_factory=list,
        description="Job names this depends on (for schedule_type='dependency')",
    )

    @field_validator("job_name")
    @classmethod
    def validate_job_name(cls, v: str) -> str:
        if not re.match(r"^[a-z][a-z0-9_]*$", v):
            raise ValueError(
                "job_name must be snake_case (lowercase, start with letter, "
                "only letters, numbers, and underscores)"
            )
        return v

    @field_validator("domain")
    @classmethod
    def validate_domain(cls, v: str) -> str:
        if not re.match(r"^[a-z][a-z0-9_]*$", v):
            raise ValueError(
                "domain must be snake_case (lowercase, start with letter, "
                "only letters, numbers, and underscores)"
            )
        return v


class TableMetadata(BaseModel):
    """Metadata about a table in the data lake, used as context for the LLM."""

    name: str = Field(..., description="Table name")
    domain: str = Field(..., description="Business domain")
    layer: str = Field(default="silver", description="Data layer: silver or gold")
    columns: list[dict] = Field(
        default_factory=list,
        description="Column definitions with name, type, description",
    )
    sample_data: list[dict] = Field(
        default_factory=list,
        description="Sample rows from the table (up to 5)",
    )
    row_count: int | None = Field(
        default=None,
        description="Approximate number of rows in the table",
    )


class TransformationPlan(BaseModel):
    """
    Structured transformation plan generated by the Transformation Agent.

    Contains a list of gold-layer jobs derived from analyzing ingested tables,
    their correlations, and domain-specific business logic.
    """

    domain: str = Field(
        ...,
        description="Business domain these transformations belong to",
    )
    source_tables: list[str] = Field(
        default_factory=list,
        description="Silver-layer tables used as input for transformations",
    )
    jobs: list[TransformJob] = Field(
        default_factory=list,
        description="List of transformation jobs to create",
    )
    rationale: str = Field(
        default="",
        description="Overall reasoning for the generated transformations",
    )

    @field_validator("domain")
    @classmethod
    def validate_domain(cls, v: str) -> str:
        if not re.match(r"^[a-z][a-z0-9_]*$", v):
            raise ValueError(
                "domain must be snake_case (lowercase, start with letter, "
                "only letters, numbers, and underscores)"
            )
        return v
